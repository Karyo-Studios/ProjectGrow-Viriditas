using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System.Threading.Tasks;
using Sirenix.OdinInspector;
using System;


// TODO - should NPC inherit from AI and the behaviors identified here should be Behaviors?
public class NPC : Character
{
    // these identify the NPC relative to other NPCs
    public new string name;
    [SerializeField] private Color color;

    [Header("--AI prompts and settings--")]
    [Title("Specific character prompt part 2", bold: false)]
    [HideLabel]
    [MultiLineProperty(12)]
    [SerializeField] private string specificCharacterPrompt_part2;  // character, colleague and work description.

    [Title("Description of this NPC's Custom Action for nearby NPCs", bold: false)]
    [HideLabel]
    [MultiLineProperty(4)]
    [SerializeField] public string customActionTextDescription; // eg - "Dr. Lena Morrow is working, reviewing the research reports that are generated by the scientists of the Village. "

    [SerializeField] public NPC_PlayerObjective[] playerObjectives;  // a list of objectives that this NPC will be prompted with the option to give the player, if the correct conditions are met

    [Header("--Custom action--")]
    // specific to this NPC, these determine how they perform their custom action
    [SerializeField] private NPC_Location customActionLocation;  // you use the interact point and faceMe at this location
    [SerializeField] private float durationPerformCustomAction = 120f; // when performing custom action, how long do you spend doing it?


    public enum OpenAIModel
    {
        RandomOffline, // Dooesn't call openAI, makes random choices.
        GPT_3_5,
        GPT_4,
    }
    [SerializeField] private OpenAIModel openAIModel = OpenAIModel.RandomOffline;
    private bool useOpenAI => ((openAIModel != OpenAIModel.RandomOffline) && (Vector3.Distance(transform.position, player.transform.position) < npc_data.distanceToUseRandomActions));
    [SerializeField] private int maxDialogHistoryToUseInPrompts = 3;  // at most, the prompt will only refer to this number of recent dialog exchanges


    [Header("--Debugging--")]
    // when true, the NPC spews a bunch of diagnostics into the log
    public bool DEBUG_NPCActions;  // the mechanics of an NPC following instructions
    public bool DEBUG_AIPrompts;   // what prompts we send to the AI model and what replied we get back
    [SerializeField] private bool DEBUG_overrideRandomOfflineGoal;  // TODO - support this
    [SerializeField] private NPC_Goal DEBUG_offlineGoal;

    [Header("--References--")]
    // this is a link to common data shared by all NPCs (it's a GO instantiated in the scene but probably should be a Scriptable Object or similar)
    [SerializeField] NPC_Data npc_data;
    // references to scene objects
    [SerializeField] private Canvas dialogCanvas;
    [SerializeField] public TextMeshPro nameLabel;
    [SerializeField] private TextMeshProUGUI dialogText;
    [SerializeField] private GameObject selectionIndicator;
    [SerializeField] private GameObject specialActionIndicator;
    [SerializeField] private GameObject awaitingInstructionsIndicator;
    [SerializeField] public Transform standHereToTalkToMe;


    // Display current state as readonly data in the inspector.
    [Header("--Current state--")]
    [ReadOnly, SerializeField] public NPC_Goal currentGoal;
    [ReadOnly, SerializeField] public NPC_Behavior currentBehavior;
    public bool IsAwaitingInstructions => (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.AwaitingInstructions);
    [ReadOnly, SerializeField] public string currentLocation;
    [ReadOnly, SerializeField] private float timeBehaviorWillConclude;
    [ReadOnly, SerializeField] private float timeDialogUiShouldClose;

    private BM_Walk myBMWalk;
    private Player player;

    // data used to track simulation state to generate openAI prompts
    public class DialogEvent
    {
        public string speaker;
        public string listener;
        public string dialog;
        public string location;
        public float timeStamp;

        public DialogEvent(string speaker, string listener, string dialog, string location)
        {
            this.speaker = speaker;
            this.listener = listener;
            this.dialog = dialog;
            this.location = location;
            timeStamp = Time.time;
        }
    }
    private List<DialogEvent> dialogHistory;



    private void Awake()
    {
        player = Karyo_GameCore.Instance.player;

        // set my name label
        if (nameLabel != null)
            nameLabel.text = name;

        // set my custom color
        MeshRenderer mr = GetComponentInChildren<MeshRenderer>();
        if (mr != null)
            mr.material.color = color;

        if (npc_data == null)
            Debug.LogError($"npc_data not assigned in NPC {this.name}, {name}");

        // validate components and references
        myBMWalk = GetComponent<BM_Walk>();
        if (myBMWalk == null)
            Debug.LogError($"NPC does not have BM_Walk component {this.name}, {name}");

        if (dialogCanvas == null)
            Debug.LogError($"dialogCanvas not defined in {gameObject.name}, {name}");
        if (dialogText == null)
            Debug.LogError($"dialogText not defined in {gameObject.name}, {name}");
        if (selectionIndicator == null)
            Debug.LogError($"selectionIndicator not defined in {gameObject.name}, {name}");
        if (specialActionIndicator == null)
            Debug.LogError($"customActionIndicator not defined in {gameObject.name}, {name}");
        if (awaitingInstructionsIndicator == null)
            Debug.LogError($"awaitingInstructionsIndicator not defined in {gameObject.name}, {name}");

        // check prompts to make sure player name is defined correctly
        if (specificCharacterPrompt_part2.Contains("Ash Trotman-Grant"))
            Debug.LogWarning($"The string 'Ash Troman-Grant' was found in specificCharacterPrompt_part2 for NPC {this.name}. Use the string '[PLAYERNAME] instead.");
        if (specificCharacterPrompt_part2.Contains("[PLAYERNAME]"))
            specificCharacterPrompt_part2 = specificCharacterPrompt_part2.Replace("[PLAYERNAME]", player.playerName);

        foreach (NPC_PlayerObjective objective in playerObjectives)
            objective.Validate(player);

        // dialog and indicators start off
        dialogCanvas.gameObject.SetActive(false);
        specialActionIndicator.SetActive(false);
        awaitingInstructionsIndicator.SetActive(false);

        currentGoal = new NPC_Goal(NPC_Goal.NPC_GoalType.Nothing);

        // all NPCs start in idle. within 20 seconds it will end, causing them to pick a new goal by calling UdpateCurrentGoal()
        currentBehavior = NPC_Behavior.Idle();
        timeBehaviorWillConclude = UnityEngine.Random.Range(2f, 15f);

        // clear history
        currentLocation = NPC_Data.startingLocationName; // TODO - set this to a location the NPC starts inside of (requires supporting this - figuring out what volume you started inside)
        dialogHistory = new List<DialogEvent>();
    }




    // called after currentGoal is fulfilled or cancelled.
    // sets new currentGoal either from openAI or randomly, depending on settings.  and then initiates pursuit of that goal.
    private async void UpdateCurrentGoal()
    {
        currentGoal = await GetNewGoal();

        if (currentGoal == null)
            currentGoal = new NPC_Goal(NPC_Goal.NPC_GoalType.Nothing);  // this happens most commonly when we can't parse the reply from openAI

        PursueGoal(currentGoal);
    }

    // farms out the goal to the various Initiate behavior methods
    private void PursueGoal(NPC_Goal goal)
    {
        if (goal.goalType == NPC_Goal.NPC_GoalType.Nothing)
            InitiateBehavior_Idle();
        else if (goal.goalType == NPC_Goal.NPC_GoalType.MoveTo)
            MoveToTransform(goal.destination.GetAvailableStandPosition(), goal.destination.locationName, false);
        else if (goal.goalType == NPC_Goal.NPC_GoalType.TalkTo)
            InitiateBehavior_Dialog(goal.targetCharacter);
        else if (goal.goalType == NPC_Goal.NPC_GoalType.PerformCustomAction)
            InitiateBehavior_CustomAction();
        else if (goal.goalType == NPC_Goal.NPC_GoalType.GivePlayerObjective)
        {
            // TODO - it would be better to give the objective at the same time as the dialog, since then if the NPC can't talk to the player, they won't get the objective with no assocaited dialog
            Karyo_GameCore.Instance.CreateObjective(goal.playerObjective);
            InitiateBehavior_Dialog(player.playerName);
        }
    }



    private void Update()
    {
        // in case your behavior changed while the dialog window was open, still close the dialog window at the appropriate time
        if (dialogCanvas.gameObject.activeInHierarchy)
        {
            if (Time.time > timeDialogUiShouldClose)
                dialogCanvas.gameObject.SetActive(false);
        }


        // check for updates, interruptions, and conclusions of current behavior 


        // if the person you are talking to moves away from you, then break off your speaking behavior
        // TODO - what if the person you're listening to walks away from you?  where is that handled?
        if ((currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.SpeakingTo) && (!DialogTargetIsNearby()))
        {
            if (DEBUG_NPCActions)
                Debug.Log($"NPC _{name} breaking off Speaking behavior with _{currentGoal.targetCharacter} because they moved away.");

            ConcludeBehavior_SpeakingTo();
            return;
        }

        // if your behavior timer expires, conclude your current behavior and determine what to do next
        if (Time.time > timeBehaviorWillConclude)
        {
            if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.SpeakingTo)
                ConcludeBehavior_SpeakingTo();

            else if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.PerformingCustomAction)
                ConcludeBehavior_CustomAction();

            else if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.Idle)
                ConcludeBehavior_Idle();
        }
    }



    private async Task<NPC_Goal> GetNewGoal()
    {
        if (useOpenAI)
        {
            NPC_Goal goal = await GetNewGoalFromOpenAI();
            return goal;
        }

        if (DEBUG_AIPrompts)
        {
            // generate a prompt and spew it to the console for debugging purposes, even though we don't send it to openAI
            string userInputPrompt = NPC_openAI.GenerateUserInputPrompt(this, npc_data, player, dialogHistory, maxDialogHistoryToUseInPrompts);
            Debug.Log($"PROMPT _{name} generated this userInputPrompt (not sending to openAI because RandomOffline): {userInputPrompt}");
        }

        return NPC_RandomGoal.GenerateRandomGoal(this, npc_data, player);
    }

    // generates a prompt and sends it to openAI.  waits for a response.  parses the response for a goal and returns it.
    private async Task<NPC_Goal> GetNewGoalFromOpenAI()
    {
        // base prompt is parts 1 and 2. for the most part, it is the same every time for a given NPC.
        string baseOpenAIPrompt = npc_data.genericPrompt_part1 + "\n" + specificCharacterPrompt_part2 + "\n\n";

        // the exception is the part 2b, objectives, which is appended to the end under certain conditions.
        if (IncludeObjectivesPromptPart2b())
            baseOpenAIPrompt = baseOpenAIPrompt + NPC_openAI.GeneratePart2bObjectivesPrompt(this) + "\n\n";

        // userInputPrompt is generated dynamically based on game state
        string userInputPrompt = NPC_openAI.GenerateUserInputPrompt(this, npc_data, player, dialogHistory, maxDialogHistoryToUseInPrompts);

        if (DEBUG_AIPrompts)
            Debug.Log($"PROMPT _{name} sending to openAI: {baseOpenAIPrompt}\n   -----\n{userInputPrompt}");
 
        currentBehavior = NPC_Behavior.AwaitingInstructions();
        awaitingInstructionsIndicator.SetActive(true);

        string response = await Karyo_GameCore.Instance.openAiService.GetChatCompletionAsync(openAIModel == OpenAIModel.GPT_3_5 ? OpenAI.Models.Model.GPT3_5_Turbo : OpenAI.Models.Model.GPT4,
                baseOpenAIPrompt, userInputPrompt);

        // execution resumes down here when response has been filled by openAI

        if (DEBUG_AIPrompts || DEBUG_NPCActions)
            Debug.Log($"PROMPT _{name} received from openAI: {response}");

        awaitingInstructionsIndicator.SetActive(false);

        NPC_Goal parsed_goal = NPC_openAI.ProcessTextFromAI(response, this, npc_data, player);

        if (DEBUG_AIPrompts || DEBUG_NPCActions)
        {
            if (parsed_goal != null)
                Debug.Log($"PROMPT: _{name} parsed AI response, GOAL = {parsed_goal.ToString()}");
            else
                Debug.Log($"PROMPT: _{name} could not parse AI response for a valid goal.");
        }

        return parsed_goal;
    }


    // returns true if the NPC should hear about its objective-related situations, ie - if prompt part 2b should be included
    private bool IncludeObjectivesPromptPart2b()
    {
        // never include at the very beginning (this encourages NPCs to go to their work stations when they first arrive in the sim)
        if (Time.time < npc_data.objectiveExclusionDuration)
            return false;

        // if the player has an objective, we don't want the NPCs engaging in dialog that could lead to them wanting to give the player a new objective
        if (Karyo_GameCore.Instance.DoesPlayerCurrentlyHaveAnObjective())
            return false;

        // only randomly include it a certain percentage of the time
        float rand = UnityEngine.Random.Range(0f, 1f);
        if (rand < npc_data.objectiveInclusionPercentChance)
            return true;
        else
            return false;
    }


    // returns true if the NPC should be given the option to offer the player an objective, ie - do we use prompt 5 (false) or 5b (true)?
    public bool UsePrompt5bObjectives ()
    {
        // if the player already has an objective, don't give them another one
        if (Karyo_GameCore.Instance.DoesPlayerCurrentlyHaveAnObjective())
            return false;

        // if this NPC's objectives are all fulfilled, then they shouldn't be given the prompt to suggest more objectives, since their list of possible objectives will be empty
        bool has_at_least_one_unfulfilled_objective = false;
        foreach (NPC_PlayerObjective objective in playerObjectives)
            if (!Karyo_GameCore.Instance.HasPlayerAlreadyFulfilledThisObjective(objective))
                has_at_least_one_unfulfilled_objective = true;
        if (!has_at_least_one_unfulfilled_objective)
            return false;

        // the basic criteria is: the current conversation has involved the player for X amount of turns, and the player is nearby
        return (HasBeenTalkingToPlayer() && IsNearby(transform.position, player.transform.position, currentLocation, player.currentLocation));
    }

    // true if you have N recent dialog exchanges in which the player participated
    // N is defined by requiredConversationDepth in NPC_Data
    public bool HasBeenTalkingToPlayer()
    {
        int player_exchanges = 0;

        foreach (DialogEvent d_event in dialogHistory)
            if ((d_event.speaker == player.playerName) || (d_event.listener == player.playerName))
                player_exchanges++;

        return (player_exchanges >= npc_data.requiredConversationDepth);
    }



    // TODO - pass in an enum that sets the idle timer to different values, longer when waiting for player responses, for example
    private void InitiateBehavior_Idle()
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} entering Idle behavior."); // TODO - say for what reason using the enum mentioned above

        currentGoal = new NPC_Goal(NPC_Goal.NPC_GoalType.Nothing);  // clear your goal so you're not blocking other dialog attempts, etc..
        currentBehavior = NPC_Behavior.Idle();
        timeBehaviorWillConclude = Time.time + UnityEngine.Random.Range(npc_data.idleDurationMin, npc_data.idleDurationMax);
    }


    private void InitiateBehavior_CustomAction()
    {
        MoveToTransform(customActionLocation.interactPoint.position, customActionLocation.locationName, true);
    }


    private void InitiateBehavior_Dialog(string targetCharacter)
    {
        Transform targetTransform;
        UnityEngine.Vector3 destination;

        if (!IsValidDialogTargetForNPC(this, targetCharacter, npc_data, player, true))
        {
            if ((DEBUG_AIPrompts) || (DEBUG_NPCActions))  
                Debug.Log($"NPC _{name} can't talk to _{targetCharacter} because they are not a valid dialog target right now.");

            InitiateBehavior_Idle();
            return;
        }

        if (targetCharacter == player.playerName)
        {
            targetTransform = player.transform;
            destination = new UnityEngine.Vector3(targetTransform.position.x, targetTransform.position.y, targetTransform.position.z - 1.3f); // TODO - instead of magic number should be data-driven offset

            MoveToTransform(destination, player.playerName);
            return;
        }

        NPC target = npc_data.GetNPCByName(targetCharacter);
        target.TargetedForSpeaking(this.name);
        destination = new UnityEngine.Vector3(target.standHereToTalkToMe.position.x, target.standHereToTalkToMe.position.y, target.standHereToTalkToMe.position.z);

        MoveToTransform(destination, targetCharacter);
    }




    private void ConcludeBehavior_SpeakingTo()
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} concluding speaking to _{currentGoal.targetCharacter}.");

        dialogCanvas.gameObject.SetActive(false);

        if (currentGoal.targetCharacter != player.playerName)
        {
            NPC target = npc_data.GetNPCByName(currentGoal.targetCharacter);
            target.WasSpokenToBy(this.name, currentGoal.dialog);
        }

        // after speaking, we idle to give the listener time to reply
        InitiateBehavior_Idle();  // TODO - pass in an enum that sets the idle timer to different values, longer here to give the player time to type
    }


    private void ConcludeBehavior_CustomAction()
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} concluding custom action.");
        specialActionIndicator.SetActive(false);
        UpdateCurrentGoal();
    }


    private void ConcludeBehavior_Idle()
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} concluding idle behavior.");
        UpdateCurrentGoal();
    }



    // called by behaviors that need to go somewhere (including, say, custom action and speaking where the NPC goes somewhere first, then does something else).
    // initiates a move towards the destination by using BM_Walk.  desinationName is only passed in for debug spew.
    public void MoveToTransform(UnityEngine.Vector3 destination, string destinationName)
    {
        MoveToTransform(destination, destinationName, false);
    }
    public void MoveToTransform(UnityEngine.Vector3 destination, string destinationName, bool alwaysMove)
    {
        // if you were speaking to someone when you decided to move somewhere, it's probably because the player spoke to you while your dialog was still displayed.
        if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.SpeakingTo)
        {
            // TODO - if this never comes up, delete this little code block
            Debug.LogWarning($"NPC _{name} who was in SpeakingTo behavior has decided to move. Randy didn't think this case was possible, since NPCs who are spoken to should change to Behavior = BeingSpokenTo.");
            dialogCanvas.gameObject.SetActive(false);
        }

        currentBehavior = NPC_Behavior.Moving(destinationName);

        // check to see if we are already there (or close enough) and if so, call ArrivedAtLocation() directly
        if ((!alwaysMove) && (IsNearby(transform.position, destination, currentLocation, destinationName)))
        {
            if (DEBUG_NPCActions)
                Debug.Log($"NPC _{name} wanted to move to {destinationName} but is already there, so no need.");
            ArrivedAtLocation(false);
        }
        else
        {
            if (DEBUG_NPCActions)
                Debug.Log($"NPC _{name} starting move to location {destinationName}");

            bool success = myBMWalk.InitiateMoveTowardsDestination(destination);

            if (!success)  // pathfinding failed
            {
                // if we were going to talk to an NPC, tell them they are no longer being talked to so they don't lock up
                if (currentGoal.goalType == NPC_Goal.NPC_GoalType.TalkTo)
                {
                    NPC NPCtarget = npc_data.GetNPCByName(currentGoal.targetCharacter);
                    if (NPCtarget != null)
                        NPCtarget.BeingSpokenTo_Cancelled(name);
                }
                InitiateBehavior_Idle();
            }
        }
    }

    // called by AI_Mover when the NPC arrives at a destination.
    // this method chooses the next behavior, eg: if you came here to talk to someone or perform your custom action, that happens next.
    public void ArrivedAtLocation()
    {
        ArrivedAtLocation(true);
    }
    public void ArrivedAtLocation(bool spewWhenArrived)
    {
        if (spewWhenArrived && DEBUG_NPCActions)
            Debug.Log($"NPC _{name} has arrived at location {currentBehavior.destination}.");

        if (currentGoal.goalType == NPC_Goal.NPC_GoalType.MoveTo)
        {
            // if you came here just to come here...
            if (useOpenAI)
                InitiateBehavior_Idle();  // UpdateCurrentGoal();  // ...let them know they've arrived  TODO - this may produce some thrashing where they instantly go somewhere else, so maybe best to idle at least a little while
            else
                InitiateBehavior_Idle();  // ...just wait around
        }

        else if ((currentGoal.goalType == NPC_Goal.NPC_GoalType.TalkTo) || (currentGoal.goalType == NPC_Goal.NPC_GoalType.GivePlayerObjective))
        {
            if (!DialogTargetIsNearby())
            {
                if (DEBUG_NPCActions)
                    Debug.Log($"NPC _{name} arrived at location where they expected to find _{currentGoal.targetCharacter} but they are not here. Attempting to move to their new location.");
                InitiateBehavior_Dialog(currentGoal.targetCharacter);
                return;
            }

            // we've arrived at the character we want to talk to
            if (currentGoal.targetCharacter == player.playerName)
            {
                FaceTarget(player.transform);
            }
            else
            {
                NPC target = npc_data.GetNPCByName(currentGoal.targetCharacter);

                if ((target.currentBehavior.behaviorType != NPC_Behavior.NPC_BehaviorType.BeingSpokenTo) || (target.currentBehavior.beingSpokenToBy != name))
                {
                    // if we arrive and the NPC target is no longer in the state of being spoken to by me, then something interrupted it while i was on my way.
                    // presuambly only the player could cause this to happen, since NPCs are carefully orchestrated to take turns.
                    if (DEBUG_NPCActions)
                        Debug.Log($"NPC _{name} arrived at _{currentGoal.targetCharacter} but they were no longer being spoked to by me.  Probably the player got here first.");
                    UpdateCurrentGoal();
                    return;
                }

                target.BeingSpokenTo(name);
                FaceTarget(target.transform);
            }

            Speak(currentGoal.targetCharacter, currentGoal.dialog);
        }

        else if (currentGoal.goalType == NPC_Goal.NPC_GoalType.PerformCustomAction)
        {
            if (DEBUG_NPCActions)
                Debug.Log($"NPC _{name} entering custom action behavior.");
            specialActionIndicator.SetActive(true);
            FaceTarget(customActionLocation.faceMe);
            timeBehaviorWillConclude = Time.time + durationPerformCustomAction;
            currentBehavior = NPC_Behavior.PerformingCustomAction();
        }

        else
        {
            Debug.LogError($"NPC _{name} can't process current action type of {currentGoal.goalType.ToString()}");
            InitiateBehavior_Idle();
        }
    }


    // called by AI_Mover when the pathfinder gives up on getting to a destination
    public void CantGetToDestination()
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} gave up on attempting to pathfind to current goal location: {currentGoal.goalType.ToString()}, switching to Idle behavior.");

        UpdateCurrentGoal();
    }


    // Lifecycle of a collaborative speaker-listener relationship among NPCs:
    //    Speaker NPC has decided to speak to Listener NPC  (by calling PursueGoal which calls InitiateDialog)
    //    Speaker calls TargetedForSpeaking() on Listener to lock listener
    //    Speaker uses MoveToTransform to start walking towards listener
    //    note that the player could interrupt either speaker or listener during this stage  
    //    Speaker calls ArrivedAtLocation() when they arrive, which checks for unepxected state changes
    //    if speaker proceeds, they call BeingSpokenTo() on listener and Speak() on themselves, which causes speaker to enter Speaking behavior.
    //    when speaker's speaking behavior concludes, they call WasSpokenToBy() on listener, so listener can choose a new goal based on what was said.

    // When NPCs speak to Player, they do the same except for that they don't call TargetedForSpeaking() or BeingSpokenTo(), ie - they just
    // move to the player then call Speak().

    // Lifecycle of Player speaking to NPC:
    //    Player calls BeingSpokenTo() on listener (they skip TargetedForSpeaking) as soon as they start entering dialog text.
    //    If player moves away or abort, they call BeingSpokenTo_Cancelled on listener.
    //    When player submits dialog, they call WasSpokenToBy() on listener.


    // this is called by one NPC on another NPC when the first makes the decision to speak to the second.
    // note that the speaker may be far away from the listener, but starts walking towards the listener after calling this.
    // the primary purpose is to change the listener's state to beingSpokenTo
    // which prevents the listener from deciding to take some other action before the speaker arrives (excepting cases where the player gets involved).
    // this should never be called by the Player (the player calls BeingSpokenTo directly instead).
    public void TargetedForSpeaking(string fromCharacter)
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} is being targeted for speaking by _{fromCharacter}");

        if (fromCharacter == player.playerName)
            Debug.LogWarning("Player should call BeingSpokenTo(), not TargetedForSpeaking()");

        currentBehavior = NPC_Behavior.BeingSpokenTo(fromCharacter);
    }


    // called by an NPC speaker on an NPC listener when the speaker has arrived at the listener's location.
    // this only happens if the NPC called TargetedForSpeaking() on the listener first.
    // also called by the Player on an NPC when the Player initiates dialog with the NPC, opens the dialog input window, etc..
    public void BeingSpokenTo(string fromCharacter)
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} is being spoken to by _{fromCharacter}");

        // if you had been speaking to someone, let them know they are no longer being spoken to, so they don't lock up
        if (currentGoal.goalType == NPC_Goal.NPC_GoalType.TalkTo)
            BeingSpokenTo_Cancelled(currentGoal.targetCharacter);

        // if you had been working, turn off your custom action indicator.  
        specialActionIndicator.SetActive(false);

        if (fromCharacter == player.playerName)
        {
            FaceTarget(player.transform);

            // the player can talk to you at nearly any time and therefore might be interrupting you on your way to something, etc.
            // so clear your old behavior
            currentGoal = new NPC_Goal(NPC_Goal.NPC_GoalType.Nothing);
            // TODO - this needs to stop the NPC from moving if they were going somewhere, or else it causes bugs

            // tell all the other NPCs that the player is talking to you.
            foreach (NPC npc in npc_data.allNPCs)
                if (npc != this)
                    npc.IsBeingSpokenToByPlayer(this);
        }
        else
        {
            FaceTarget(npc_data.GetNPCByName(fromCharacter).transform);
        }

        currentBehavior = NPC_Behavior.BeingSpokenTo(fromCharacter);
    }


    // called after NPC calls TargetedForSpeaking, or after player calls BeingSpokenTo.
    // tells the NPCs that the speaker has decided not to talk to them after all.
    public void BeingSpokenTo_Cancelled(string fromCharacter)
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} is no longer being spoken to by _{fromCharacter}");

        InitiateBehavior_Idle();  // this will change the NPC's state from beingSpokenTo, and when idle concludes they will pick a new goal
    }


    // called by an NPC when the player started talking to them (ie - presses the interact key, open the dialog entry window, and calls BeingSpokenTo).
    // the listener calls this on all other NPCs so they can break off their dialog with the player and therefore
    // no longer lock the player for dialog (ie - the NPC the player is speaking to will probably want to reply).
    public void IsBeingSpokenToByPlayer(NPC speaker)
    {
        if (!IsInDialogWithCharacter(player.playerName))
            return;

        if (DEBUG_NPCActions)
        {
            if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.SpeakingTo)
                Debug.Log($"NPC _{name} had been speaking to _{player.playerName} but is breaking off because _{speaker.name} is now being spoken to by _{player.playerName}.");
            else if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.BeingSpokenTo)
                Debug.Log($"NPC _{name} was being spoken to by _{player.playerName} but is breaking off because _{speaker.name} is now being spoken to by _{player.playerName}.");
        }

        InitiateBehavior_Idle();  // TODO - this type is participating in conversation, ie - listening for replies
    }



    // this method actually displays the NPC's dialog in the in-world HUD,
    // sets the behavior to Speaking and sets timer for when the Behavior ends
    public void Speak(string toCharacter, string dialog)
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} speaking to _{toCharacter} and saying: {dialog}");

        // remember this dialog event and if you're speaking to an NPC tell them to remember it too.
        // this used to happen only after the dialog event concluded, but then if it was interrupted it wouldn't be remembered,
        // which is very common when back-and-forth talking to the player.
        DialogEvent dialogEvent = new DialogEvent(name, toCharacter, dialog, currentLocation);  // TODO - tracking location this way has some potential flaws, eg - if the speaker and listener happen to be in 2 different locations due to a boundary between them
        RememberDialogEvent(dialogEvent);

        if (toCharacter != player.playerName)
        {
            NPC target = npc_data.GetNPCByName(toCharacter);
            if (target != null)
                target.RememberDialogEvent(dialogEvent);
        }

        CheckForEavesdropping(dialogEvent); // if any other NPCs are nearby, they also remember this event

        string text = new string("Speaking to: ");
        text = text + toCharacter + '\n' + '\n';
        text = text + dialog;

        dialogText.text = text;
        dialogCanvas.gameObject.SetActive(true);

        int wordCount = GetWordCount(dialog);
        float durationOfDialog = (npc_data.duration_SecPerWord * wordCount);
        durationOfDialog = Mathf.Clamp(durationOfDialog, npc_data.minDialogDuration, npc_data.maxDialogDuration);

        timeBehaviorWillConclude = Time.time + durationOfDialog;
        timeDialogUiShouldClose = timeBehaviorWillConclude;

        currentBehavior = NPC_Behavior.Speaking();
    }

    // when an NPC talks to an NPC, this gets called on the listening NPC after the Speaking behavior of the speaking NPC concludes.
    // when player talks to an NPC, this gets called on the listening NPC when the player submits the dialog.
    public void WasSpokenToBy(string fromCharacter, string dialog)
    {
        if (DEBUG_NPCActions)
            Debug.Log($"NPC _{name} was spoken to by _{fromCharacter} who said: {dialog}");

        if ((currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.BeingSpokenTo) && (currentBehavior.beingSpokenToBy == fromCharacter))
        {
            UpdateCurrentGoal();
        }
        else
        {
            // this handles the case where the player interrupts an NPC being spoken to by another NPC, eg - by also speaking to the listener.
            // the NPC could be in various states, including AwaitingInstructions from openAI, or on their way to perform some other action of their choice.
            // since this new behavior was presumably triggered by the player speaking to the NPC, we don't interrupt it.
            if (DEBUG_NPCActions)
                Debug.Log($"NPC _{name} will not respond to _{fromCharacter} because {name} is already doing this behavior: {currentBehavior.ToString()}");
        }

    }


    // this next section is helper methods 

    public static bool IsValidDialogTargetForNPC(NPC speaker, string target, NPC_Data npc_data, Player player, bool allowDebugSpew)
    {
        bool spew = allowDebugSpew && (speaker.DEBUG_AIPrompts || speaker.DEBUG_NPCActions);

        // don't talk to yourself
        if (speaker.name == target)
        {
            if (spew)
                Debug.Log($"_{target} is not a valid dialog target, because this NPC is {target}");
            return false;
        }

        if (target == player.playerName)
        {
            foreach (NPC npc in npc_data.allNPCs)
                if (npc != speaker)
                    if (npc.IsInDialogWithCharacter((player.playerName)))  
                        if (npc.IsNearby(npc.transform.position, player.transform.position, npc.currentLocation, player.currentLocation)) // you have to be near the player to lock them for dialog.  this handles the case where an NPC considers themselves in dialog with the player due to their goal, but in reality they are walking towards the player from across the map and the player is actually in dialog with a more nearby NPC.
                        {
                            if (spew)
                                Debug.Log($"_{target} is not a valid dialog target for _{speaker.name}, because {target} is already talking to _{npc.name}");
                            return false;
                        }

            return true;
        }

        NPC targetNPC = npc_data.GetNPCByName(target);
        if (targetNPC == null)
        {
            if (spew)
                Debug.Log($"_{target} is not a valid dialog target for _{speaker.name}, because there is no known NPC with that name.");
            return false;
        }

        // if target is currently awaiting instructions, return false
        if (targetNPC.currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.AwaitingInstructions)
        {
            if (spew)
                Debug.Log($"_{target} is not a valid dialog target for _{speaker.name}, because they are waiting to hear back from openAI.");
            return false;
        }

        // UPDATE - we currently support talking to moving targets, because the code checks upon arrival and attempts to move to their location again if they're not there.
        // TODO - but what if you successfully intercept them?  after 60 sec their pathfinding might fail, right?  can we cancel the pathfinding? UPDATE - it seems they ignore you, continue walking, and your dialog breaks off when they walk far away?
        // if target is currently moving,  return false
        // unless they are moving to the location they currently are, in which case we can assume they're close enough and they'll be here a while
        if (targetNPC.currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.Moving)
            if (targetNPC.currentBehavior.destination != targetNPC.currentLocation)
            {
                if (spew)
                    Debug.Log($"_{target} is a valid dialog target for _{speaker.name}, but note they are moving to {targetNPC.currentBehavior.destination} from {targetNPC.currentLocation}");
                // return false;
            }

        // if target is speaking to anyone other than me, return false
        if ((targetNPC.currentGoal.goalType == NPC_Goal.NPC_GoalType.TalkTo) && (targetNPC.currentGoal.targetCharacter != speaker.name))
        {
            if (spew)
                Debug.Log($"_{target} is not a valid dialog target for _{speaker.name}, because they are speaking to _{targetNPC.currentGoal.targetCharacter}.");
            return false;
        }
        if ((targetNPC.currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.BeingSpokenTo) && (targetNPC.currentBehavior.beingSpokenToBy != speaker.name))
        {
            if (spew)
                Debug.Log($"_{target} is not a valid dialog target for _{speaker.name}, because they are being spoken to by _{targetNPC.currentBehavior.beingSpokenToBy}.");
            return false;
        }

        // otherwise they are a valid target
        return true;
    }


    public bool IsInDialogWithCharacter(string characterName)
    {
        if (currentGoal != null)
            if (currentGoal.goalType == NPC_Goal.NPC_GoalType.TalkTo)
                if (currentGoal.targetCharacter == characterName)
                    return true;

        if (currentBehavior.behaviorType == NPC_Behavior.NPC_BehaviorType.BeingSpokenTo)
            if (currentBehavior.beingSpokenToBy == characterName)
                return true;

        return false;
    }



    private static int GetWordCount(string input)
    {
        // Split the input string into words using whitespace as the delimiter
        string[] words = input.Split(new char[] { ' ', '\t', '\n', '\r' }, System.StringSplitOptions.RemoveEmptyEntries);

        // Return the count of words
        return words.Length;
    }


    public void RememberDialogEvent(DialogEvent dialogEvent)
    {
        if (dialogEvent != null)
            dialogHistory.Add(dialogEvent);
    }

    // this is called by the NPC who was involved in the dialogEvent as the speaker.
    // if any NPCs not already in the dialogEvent were nearby at the moment the event started,
    // they also remember the event
    private void CheckForEavesdropping(DialogEvent dialogEvent)
    {
        foreach (NPC npc in npc_data.allNPCs)
            if (currentLocation != NPC_Data.startingLocationName)  // TODO - this behavior is hardcoded which is bad, we don't eavesdrop at starting location to prevent NPCs from clustering up at the beginning
                if ((npc.name != dialogEvent.speaker) && (npc.name != dialogEvent.listener))
                    if (IsNearby(npc.transform.position, transform.position, npc.currentLocation, currentLocation))
                        npc.RememberDialogEvent(dialogEvent);
    }


    private bool DialogTargetIsNearby()
    {
        if ((currentGoal.goalType != NPC_Goal.NPC_GoalType.TalkTo) && (currentGoal.goalType != NPC_Goal.NPC_GoalType.GivePlayerObjective))
        {
            Debug.LogError($"DialogTargetIsNearby() called on _{name} when their goal type is not TalkTo nor GivePlayerObjective. Their goal is {currentGoal.ToString()}");
            return false;
        }

        if (currentGoal.targetCharacter == player.playerName)
            return IsNearby(transform.position, player.transform.position, currentLocation, player.currentLocation);
        else
            return IsNearby(transform.position, npc_data.GetPositionByCharacterName(currentGoal.targetCharacter), currentLocation, npc_data.GetNPCByName(currentGoal.targetCharacter).currentLocation);
    }


    public bool IsNearby(Vector3 positionOfNPC, Vector3 positionOfTarget, string nameOfNPCLocation, string nameOfTargetLocation)
    {
        // if you're in the same named location, then you are considered nearby
        if (npc_data.IsOneOfTheNamedLocations(nameOfNPCLocation))
            if (nameOfNPCLocation == nameOfTargetLocation)
                return true;

        // if your two positions are within the tolerance, you are considered nearby (ie - if you are standing nearby regardless of your named location)
        if (Vector3.Distance(positionOfNPC, positionOfTarget) < npc_data.nearbyThreshold)
            return true;

        // otherwise you are not
        return false;
    }



    // called by Player when player starts looking at NPC so the selection indicator UI can appear
    public void StartSelection()
    {
        selectionIndicator.SetActive(true);
    }
    // called by Player when player stops looking at NPC so the selection indicator UI can go away
    public void StopSelection()
    {
        selectionIndicator.SetActive(false);
    }


    public void FaceTarget(Transform target)
    {
        FaceTarget(target, 0f);
    }
    public void FaceTarget(Transform target, float rotationOffset)
    {
        UnityEngine.Vector3 oldRotation = transform.rotation.eulerAngles;

        transform.LookAt(target);

        UnityEngine.Vector3 newRotation = transform.rotation.eulerAngles;

        newRotation.y += rotationOffset;

        // only rotate around the y axis
        newRotation.x = 0;
        newRotation.z = 0;

        transform.rotation = UnityEngine.Quaternion.Euler(newRotation);
    }


    // called by player on an NPC that the player has just started talking to in order to get dialog options from openAI
    public async Task<string[]> RequestDialogOptions()
    {
        // note that we never include prompt part 2b, player objectives, when asking an NPC for dialog options.  this is because the player shouldn't know to ask about these objectives unless they are already part of the current dialog history.
        string baseOpenAIPrompt = npc_data.genericPrompt_part1 + "\n" + specificCharacterPrompt_part2 + "\n\n";
        string userInputPrompt =  NPC_openAI.GenerateUserInputPromptForDialogOptions(this, npc_data, player, dialogHistory, maxDialogHistoryToUseInPrompts);

        if (!useOpenAI)
        {
            if (DEBUG_AIPrompts)
                Debug.Log($"PROMPT _{name} generated this userInputPrompt for player dialog options (not sending to openAI because RandomOffline): {userInputPrompt}");

            return npc_data.offlinePlayerDialogOptions;
        }


        if (DEBUG_AIPrompts)
            Debug.Log($"PROMPT _{name} sending player dialog request to openAI: {baseOpenAIPrompt}\n   -----\n{userInputPrompt}");

        // TODO - should the NPC enter AwaitingInstructions state?  Probably not, because they just entered BeingSpokenTo by player state.  But if openAI took a long time to reply, that could cause problems.

        string response = await Karyo_GameCore.Instance.openAiService.GetChatCompletionAsync(openAIModel == OpenAIModel.GPT_3_5 ? OpenAI.Models.Model.GPT3_5_Turbo : OpenAI.Models.Model.GPT4,
                baseOpenAIPrompt, userInputPrompt);

        // execution resumes down here when response has been filled by openAI

        if (DEBUG_AIPrompts || DEBUG_NPCActions)
            Debug.Log($"PROMPT _{name} received player dialog response from openAI: {response}");

        string[] dialog_options = NPC_openAI.ProcessTextFromAIForDialogOptions(response);

        if (DEBUG_AIPrompts || DEBUG_NPCActions)
        {
            if (dialog_options != null)
                Debug.Log($"PROMPT: _{name} parsed AI response for these dialog options: 1-{dialog_options[0]}, 2-{dialog_options[1]}, 3-{dialog_options[2]}");
            else
                Debug.Log($"PROMPT: _{name} could not parse AI response for dialog options.");
        }

        return dialog_options;
    }
public override void TakeDamage(float damage)
    {
        // Implement your damage logic here for NPCs
    }

    public override void Move(Vector3 direction)
    {
        // Implement your movement logic here for NPCs
    }

}
